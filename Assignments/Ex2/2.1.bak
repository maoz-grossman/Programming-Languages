; The ROL BNF and Parsing code:
#lang pl
;; Defining two new types
(define-type BIT = (U 0 1))
(define-type Bit-List = (Listof BIT))

;; The actual interpreter
#| BNF for the RegE language:
 <ROL> ::= < --fill in-- >
 <RegE> ::= {Reg <Bit-List>}
           |{Shl <RegE>}
           |{Or <RegE> <RegE>}
           |{And <RegE> <RegE>}
 <Bit-List>::=<BIT>|<Bit><Bit-List>
 <Bits> ::= {0} | {1}
 |#
;; RegE abstract syntax trees
(define-type RegE
 [Reg < --fill in-- >]
 [And < --fill in-- >]
 [Or < --fill in-- >]
 [Shl < --fill in-- >])
;; Next is a technical function that converts (casts)
;; (any) list into a bit-list. We use it in parse-sexpr.
 (: list->bit-list : (Listof Any) -> Bit-List)
 ;; to cast a list of bits as a bit-list
 (define (list->bit-list lst)
 (cond [(null? lst) null]
 [(eq? (first lst) 1)(cons 1 (list->bit-list (rest lst)))]
 [else (cons 0 (list->bit-list (rest lst)))]))
 (: parse-sexpr : Sexpr -> RegE)
 ;; to convert the main s-expression into ROL
 (define (parse-sexpr sexpr)
 (match sexpr
 < --fill in-- > ;; remember to make sure specified register length is at least 1
 [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))
 (: parse-sexpr-RegL : Sexpr Number -> RegE)



 ;; to convert s-expressions into RegEs
 (define (parse-sexpr-RegL sexpr reg-len)
 (match sexpr
 [(list (and a (or 1 0)) ... ) (< --fill in-- >
 (error 'parse-sexpr "wrong number of bits in ~s" a))]
 [< --fill in-- >]
 [< --fill in-- >]
 [< --fill in-- >]
 [else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))



 (: parse : String -> RegE)
 ;; parses a string containing a RegE expression to a RegE AST
 (define (parse str)
 (parse-sexpr (string->sexpr str)))




 ;; tests
 (test (parse "{ reg-len = 4 {1 0 0 0}}") => (Reg '(1 0 0 0)))
 (test (parse "{ reg-len = 4 {shl {1 0 0 0}}}") => (Shl (Reg '(1 0 0 0))))
 (test (parse "{ reg-len = 4 {and {shl {1 0 1 0}} {shl {1 0 1 0}}}}") => (And (Shl (Reg
'(1 0 1 0))) (Shl (Reg '(1 0 1 0)))))
 (test (parse "{ reg-len = 4 { or {and {shl {1 0 1 0}} {shl {1 0 0 1}}} {1 0 1 0}}}") =>
(Or (And (Shl (Reg '(1 0 1 0))) (Shl (Reg '(1 0 0 1)))) (Reg '(1 0 1 0))))
 (test (parse "{ reg-len = 2 { or {and {shl {1 0}} {1 0}} {1 0}}}") => (Or (And (Shl
(Reg '(1 0))) (Reg '(1 0))) (Reg '(1 0))))
 (test (parse "{ reg-len = 4 {or {1 1 1 1} {0 1 1}}}") =error> "wrong number of bits in")